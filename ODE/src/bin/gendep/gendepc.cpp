using namespace std;
#define _ODE_BIN_GENDEP_GENDEP_CPP_

#define MAX_INCLUDE_NEST_DEPTH 128

#include "base/binbase.hpp"
#include "bin/gendep/gendepc.hpp"
#include "lib/util/condeval.hpp"
#include "lib/util/cond.hpp"
#include "lib/string/variable.hpp"
#include "lib/exceptn/exceptn.hpp"
#include "lib/io/version.hpp"


/******* Initialize all constant variables ***********/

#if defined(DEFAULT_SHELL_IS_CMD) || defined(DEFAULT_SHELL_IS_VMS)
const String GenDep::DEFAULT_TARGET_SUFF = ".obj";
#else
const String GenDep::DEFAULT_TARGET_SUFF = ".o";
#endif

// Directive handled by gendep
String PREPROC_DIRECTIVE = "#";
String INCLUDE_DIRECTIVE = "#include";
String DEFINE_DIRECTIVE = "#define";
String UNDEF_DIRECTIVE = "#undef";
String IF_DIRECTIVE = "#if";
String ELSE_DIRECTIVE = "#else";
String ENDIF_DIRECTIVE = "#endif";
String ELIF_DIRECTIVE = "#elif";
String IFDEF_DIRECTIVE = "#ifdef";
String IFNDEF_DIRECTIVE = "#ifndef";

// Unhandled but legal directives
String PRAGMA_DIRECTIVE = "#pragma";
String ERROR_DIRECTIVE = "#error";
String LINE_DIRECTIVE = "#line";

// Other definitions
String BEGIN_COMMENT = "/*";
String END_COMMENT = "*/";
String LINE_COMMENT = "//";
String LEFT_PAREN = "(";
String RIGHT_PAREN = ")";
String DOUBLE_QUOTE = "\"";
String SINGLE_QUOTE = "\'";
String LINE1; // initialized in GenDep::main()
String LINE2 = "#";
String LINE3 = "# dependents of ";
int DOUBLE_QUOTE_INCLUDE = 0;
int ANGLE_BRACKET_INCLUDE = 1;

/******************************************************************************
 *
 */
int GenDep::classMain( const char **argv, const char **envp )
{
  // LINE1 initializer contains a static variable from another module,
  // hence this must be initialized after module init.
  LINE1 = "#This file was generated by ODE gendep Version ";
  LINE1 += Version::RELEASE;

  GenDep gd( argv, envp );
  return( gd.run() );
}


/******************************************************************************
 *
 */
int GenDep::run()
{
  checkCommandLine();

  StringArray inputs;
  cmdline->getUnqualifiedVariables( &inputs );

  if (inputs.length() == 0) // if no arguments entered
  {
    Interface::printError( "gendep: No source files entered!" );
    printUsage();
    Interface::quit( 1 );
  }

  initVars( inputs );

  // Process all source files
  if (srcFileNames.length() != 0)
  {
    // There should be at most one target name to use in place of
    // the default.
    if (targetNames.length() != 0)
    {
      if (targetNames.length() > 1)
      {
        Interface::printError( "gendep: too many -targname arguments" );
        printUsage();
        Interface::quit( 1 );
      }
      else if (srcFileNames.length() > 1)
      {
        Interface::printError(
            "gendep: only one source_file allowed with '-targname target_file' option" );
        printUsage();
        Interface::quit( 1 );
      }
    }
    String depFileName = cmdline->getQualifiedVariable( "-o" );
    if (depFileName != StringConstants::EMPTY_STRING &&
        srcFileNames.length() > 1)
    {
      Interface::printError(
        "gendep: only one source_file allowed with '-o output_file' option" );
      Interface::quit( 1 );
    }

    for (int i=srcFileNames.firstIndex(); i<=srcFileNames.lastIndex()
     && continueProcessing; i++)
      processSource( srcFileNames[i] );
  }
  else
    Interface::printError( "gendep: No valid source files entered!" );


  return ( 0 );
}


/******************************************************************************
 *
 */
void GenDep::checkCommandLine()
{
  const char *sts[] = { "-q", "-nodup", "-table", "-abs", "-condfalse",
                        "-hdrsonly", 0 };
  StringArray states( sts );
  const char *qsts[] = { "-D", "-I", "-E", "-s", "-targname", "-respfile", "-o", 0};
  StringArray qvars( qsts );

  StringArray arguments( args );

  checkRespfile( arguments );
  cmdline = new CommandLine( &states, &qvars, true, arguments, true, *this );
  cmdline->process();
}


/******************************************************************************
 * Process arguments, looking for -respfile filename.
 * If found, read the file(s), parse, and append items to arguments array.
 * This is called before CommandLine is created with the arguments array.
 */ 
void GenDep::checkRespfile( StringArray &arguments )
{
  String flag( "-respfile" );
  StringArray respArgs;
  String *line = 0;
  StringArray tokens;
  String filename;
  boolean debug = false;
  char  *whiteSpace = " \t\r\n";
  if ( arguments.length() != 0 )
  {
    for (int idx=arguments.firstIndex(); idx<=arguments.lastIndex(); idx++ )
    {
      if (arguments[idx].equals( "-debug" ))
        debug = true;
    }
    for (int idx2=arguments.firstIndex(); idx2<=arguments.lastIndex(); idx2++ )
    {
      if (arguments[idx2].equals( flag ))
      {
        if (++idx2 > arguments.lastIndex() || arguments[idx2].startsWith( "-" ))
        {
          Interface::printError( "gendep: " + flag +
                                 " not followed by a filename" );
          printUsage();
          Interface::quit( 1 );
        }
        filename = arguments[idx2];
        if (debug)
          Interface::printAlways( "gendep: reading arguments from response file "
                                  + filename );
        // read and parse response file, appending to arguments
        ConfigFile respfile( filename );
        if (!respfile.exists())
        {
          Interface::printWarning( "gendep: response file (" + filename +
                                   ") does not exist." );
        }
        else
        {
          line=respfile.getLine( true, false, 0, false );
          while (line != 0)
          {
            if(line->length() != 0)
            {
              if (debug)
                Interface::printAlways( "reading response file line (" +
                                        *line + ")" );
              // parse line and put items in respArgs, checking if there is
              // a -respfile item first
              tokens.clear();
              line->split( whiteSpace, UINT_MAX, &tokens );
              for (int i = tokens.firstIndex(); i <= tokens.lastIndex(); ++i)
              {
                tokens[i] = tokens[i].dequote();
                if (tokens[i].equals( flag )) 
                {
                  Interface::printError( "gendep: " + flag +
                                         " not allowed in a response file" );
                  Interface::quit( 1 );
                }
                respArgs.add( tokens[i] );
              }
            }
            line=respfile.getLine( true, false, 0, false );
          }
        }
      }
    }
    arguments +=  respArgs;
  }
}


/******************************************************************************
 *  Initialize and assign globally-used variables
 *
 *  @param srcFiles - unqualified variables from command line
 *
 */
void  GenDep::initVars( const StringArray &srcFiles )
{
  int j;

  if (Interface::isDebug())
    Interface::printDebug( "gendep: Initializing variables..." );

  // Get source files
  for (j = srcFiles.firstIndex(); j <= srcFiles.lastIndex(); j++)
  {
    File src_file(srcFiles[j], true);
    if (src_file.isFile())
    {
      if (Interface::isDebug())
        Interface::printDebug( "gendep: file " + srcFiles[j] + " exists" );
      srcFileNames.append( srcFiles[j] );
    }
    else
    {
      if (Interface::isVerbose())
        Interface::printVerbose( "gendep: Could not locate source file "
         + srcFiles[j] );
    }
  }

  // Initialize boolean states
  if (cmdline->isState( "-q" ))
      quit_if_not_found = true;
  else
      quit_if_not_found = false;
  if (cmdline->isState( "-nodup" ))
      no_dup_files = true;
  else
      no_dup_files = false;
  if (cmdline->isState( "-table" ))
      disp_table = true;
  else
      disp_table = false;
  if (cmdline->isState( "-abs" ))
      full_target_path = true;
  else
      full_target_path = false;
  if (cmdline->isState( "-condfalse" ))
      cond_truth = false;
  else
      cond_truth = true;
  if (cmdline->isState( "-hdrsonly" ))
      headersOnly = true;
  else
      headersOnly = false;

  StringArray tempDirs, splitDirs;
  // Get include search path directories
  cmdline->getQualifiedVariables( "-I", &tempDirs );
// For shells that use drive letters, a user might use "-IC:foo\bar"
// (notice no slash follows the colon), so we need to canonicalize the
// paths just in case (to find the current directory on the specified
// drive).
  for (j = tempDirs.firstIndex(); j <= tempDirs.lastIndex(); j++)
  {
    tempDirs[j].split( Path::PATH_SEPARATOR, UINT_MAX, &splitDirs );
    includeDirs += splitDirs;
  }
  for (j = includeDirs.firstIndex(); j <= includeDirs.lastIndex(); j++)
    if (!Path::absolute( includeDirs[j] ))
      Path::canonicalizeThis( includeDirs[j], false );
  if (Interface::isDebug())
  {
    Interface::printDebug( "gendep: Included Directories: " );
    if (includeDirs.isEmpty())
      Interface::printDebug( "  None");
    else
    {
      for (j = includeDirs.firstIndex(); j <= includeDirs.lastIndex(); j++)
        Interface::printDebug( "  " + includeDirs[j] );
    }
  }

  // Get exclude search path directories
  tempDirs.clear();
  cmdline->getQualifiedVariables( "-E", &tempDirs );
  for (j = tempDirs.firstIndex(); j <= tempDirs.lastIndex(); j++)
  {
    tempDirs[j].split( Path::PATH_SEPARATOR, UINT_MAX, &splitDirs );
    excludeDirs += splitDirs;
  }
  for (j = excludeDirs.firstIndex(); j <= excludeDirs.lastIndex(); j++)
    if (!Path::absolute( excludeDirs[j] ))
      Path::canonicalizeThis( excludeDirs[j], false );
  if (Interface::isDebug())
  {
    Interface::printDebug( "gendep: Excluded Directories: " );
    if (excludeDirs.isEmpty())
      Interface::printDebug( "  None");
    else
    {
      for (j = excludeDirs.firstIndex(); j <= excludeDirs.lastIndex(); j++)
        Interface::printDebug( "  " + excludeDirs[j] );
    }
  }

  // Alternative target name
  cmdline->getQualifiedVariables( "-targname", &targetNames );

  // Construct setVars object
  variables = new SetVars();

  // Initialize other variables
  continueProcessing = true;

}


/******************************************************************************
 * Generate dependencies for given sourcefile
 *
 * @param srcfilename - Full path of source file to process
 */
void GenDep::processSource( const String& srcfilename )
{
  StringArray cmdlineVars;

  if (Interface::isDebug())
    Interface::printDebug( "gendep: Processing source file " +
     srcfilename + " ... ");

  // Initialize nesting levels and hash stats info
  nestLevel = 0;
  exceededNestLimit = false;
  hash_hits = 0;
  hash_misses = 0;

  // Initialize setVars object with command line variables
  cmdline->getQualifiedVariables( "-D", &cmdlineVars );

  if ( cmdlineVars.length() != 0 )
  {
    for ( int idx=cmdlineVars.firstIndex();
     idx<=cmdlineVars.lastIndex(); idx++ )
    {
      if (cmdlineVars[idx].indexOf( StringConstants::VAR_SEP_STRING ) == 0)
        // Add a trailing '=1' if no value assigned
        variables->put(cmdlineVars[idx]+StringConstants::VAR_SEP_STRING+'1');
      else
        variables->put(cmdlineVars[idx]);
    }
  }
  
  // Clear out dependencies from previous source file
  depends.clear();

  // set the current directory of the source file
  curSourceDir = Path::filePath( srcfilename );

  // Parse the current source file
  parseSource( srcfilename );

  // Write out dependency information for current source file
  if (continueProcessing)
    writeDepInfo( srcfilename );

  if (Interface::isDebug())
    Interface::printDebug( "gendep: Done processing source file " +
     srcfilename + " ... " );

 // Debug output of setVars symbol table
  if (disp_table)
  {
    Interface::printAlways( "gendep: Symbol table for source file: " +
     srcfilename );
    StringArray* temp = variables->get();
    for (int i=temp->firstIndex(); i <= temp->lastIndex(); i++)
      Interface::printAlways( "gendep: element " + (String)i +
       " is " + (*temp)[i] );
    delete temp;
    Interface::printAlways( "" );
  }

  // Clear out setVars symbol table
  variables->clear();
  
}


/******************************************************************************
 * Parse specified source file and store dependencies
 * May be called recursively to parse files included by source files
 *
 * @param srcfilename - Full path of source file to parse
 *
 */
void GenDep::parseSource( const String& srcfilename )
{
  String *line=0;
  ConfigFile srcfile( srcfilename );
  boolean inComment = false;
  String beforeComment;
  String afterComment;
  boolean readNextLine = true;
  int i;
  char ch;
  char nextch;
  char quote;
  boolean inQuote = false;
  String temp1, temp2;
  boolean processLine = true;
  Variable var( variables, false, '$' );
  CondEvaluator condState( &srcfile, 0, &var, Cond::DEFINED_FUNC, cond_truth );

  if (Interface::isDebug())
    Interface::printDebug( "gendep: Parsing source file " +
     srcfilename + " ... " );

  if (nestLevel > MAX_INCLUDE_NEST_DEPTH)
  {
    Interface::printError ("gendep: Maximum #include nesting depth of "
     + (String)MAX_INCLUDE_NEST_DEPTH + " has been exceeded" );
    exceededNestLimit = true;
    delete line;
    line = 0;
    if (Interface::isDebug())
      Interface::printDebug( "gendep: Done parsing source file "
       + srcfilename + " ... " );
  }

  line=srcfile.getLine( true, false, 0, false );

  processLine = true;

  try {
  while((line != 0) && !exceededNestLimit && continueProcessing )
  {
    if(line->length() != 0) {

      // Comment processing
      if (inComment)
      {
      // continue to next line in file if no end comment is found
        if ((line->indexOf( END_COMMENT )) == STRING_NOTFOUND)
        {
          delete line;
          line = 0;
          line = srcfile.getLine( true, false, 0, false );
          continue;
        }
        else   // Create new line starting after end comment and continue
        {
          inComment = false;
          *line = line->substring( line->indexOf( END_COMMENT ) + 2 );
          // trim leading whitespace from line
          *line = line->trim();
          continue;
        }
      }
      else   // if not in a comment
      {
        // Replace all tabs in line with spaces
        line->replaceThis( '\t', ' ');

        // skip line if it begins with //
        if (line->startsWith( LINE_COMMENT ))
        {
          delete line;
          line = 0;
          line = srcfile.getLine( true, false, 0, false );
          continue;
        }
        else  // must process all chars of line
        {
          for (i = line->firstIndex(); i <= line->lastIndex(); i++)
          {
            ch = line->charAt( i );
            nextch = line->charAt( i+1 );

            // Line comment, cut off line after comment
            if ( !inQuote && ((ch == '/') && (nextch == '/')))
            {
              *line = line->substring( line->firstIndex(), i);
              break;
            }
            // Beginning of quoted string
            else if ( !inQuote && ((ch == '"') || (ch == '\'')))
            {
              quote = ch;
              inQuote = true;
            }
            else if (inQuote && (ch == quote))   // End of quoted string
            {
              inQuote = false;
            }
            else if (ch == '\\')  // Skip character after escape symbol
            {
              i++;
            }
            else if ((ch == '/') && (nextch == '*'))  // Begin comment found
            {
              if (!inQuote)
              {
                // Look for end comment
                if (line->indexOf( END_COMMENT ) != STRING_NOTFOUND)
                {
                  // if end comment found, remove between /* and */
                  temp1 = line->substring( line->firstIndex(), i );
                  temp2 = line->substring( line->indexOf( END_COMMENT ) + 2);
                  *line = temp1 + temp2;
                  // Decerement i to resume processing of line at same index
                  i--;
                  continue;
                }
                else
                {
                  // if no end comment, split line into before and
                  //  after begin comment
                  beforeComment = line->substring( line->firstIndex(), i );
                  afterComment = line->substring( i + 2 );
                  // flag to use afterComment as next line to process
                  //  instead of next line in file
                  readNextLine = false;
                  *line = beforeComment;
                  break;
                }
              }
            }
          }
        }
      }

      if (inQuote && Interface::isDebug())
        displayWarning(
          "Skipping line - resides in a double-quoted string: "
          + *line, srcfile);

      line->trimThis();

      // Try to find PREPROC_DIRECTIVE symbol (#)
      //  must be first symbol on line and can't be in a double-quoted string
      if (line->startsWith( PREPROC_DIRECTIVE ) && !inQuote)
      {
        // Remove extra space between # and directive name
        //  i.e. #  define VAR reduces to #define VAR
        *line = line->substring( line->indexOf( PREPROC_DIRECTIVE ) + 1 );
        *line = line->trim();
        *line = line->prepend( PREPROC_DIRECTIVE );

        // if #include
        if (line->startsWith( INCLUDE_DIRECTIVE ))
        {
          if (processLine)
            processInclude( *line, srcfile );
        }
        // if #define
        else if (line->startsWith( DEFINE_DIRECTIVE ))
        {
          if (processLine)
            processDefine( *line, srcfile );
        }
        // if #undef
        else if (line->startsWith( UNDEF_DIRECTIVE ))
        {
          if (processLine)
            processUndef( *line, srcfile );
        }
        // if #else
        else if (line->startsWith( ELSE_DIRECTIVE ))
        {
          try
          {
            processLine = condState.parseElse();
          }
          catch (Exception &e)
          {
            if (Interface::isDebug())
              Interface::printDebug(e.getMessage());
          }
          if (Interface::isDebug())
            Interface::printDebug( String( "gendep: COND: " ) + (*line) +
                " == " + ((processLine) ? "true" : "false") );
        }
        // if #endif
        else if (line->startsWith( ENDIF_DIRECTIVE ))
        {
          try
          {
            processLine = condState.parseEndif();
          }
          catch (Exception &e)
          {
            if (Interface::isDebug())
              Interface::printDebug(e.getMessage());
          }
          if (Interface::isDebug())
            Interface::printDebug( String( "gendep: COND: " ) + (*line) );
        }
        // if #elif
        else if (line->startsWith( ELIF_DIRECTIVE ))
        {
          try
          {
            processLine = condState.parseElif(
             line->substring( line->firstIndex() + 5 ).trimThis(), true );
          }
          catch (Exception &e)
          {
            if (Interface::isDebug())
              Interface::printDebug(e.getMessage());
            processLine = cond_truth;
          }
          if (Interface::isDebug())
            Interface::printDebug( String( "gendep: COND: " ) + (*line) +
                " == " + ((processLine) ? "true" : "false") );
        }
        // if #ifdef
        else if (line->startsWith( IFDEF_DIRECTIVE ))
        {
          try
          {
            processLine = condState.parseIfdef(
             line->substring( line->firstIndex() + 6 ).trimThis() );
          }
          catch (Exception &e)
          {
            if (Interface::isDebug())
              Interface::printDebug(e.getMessage());
            processLine = cond_truth;
          }
          if (Interface::isDebug())
            Interface::printDebug( String( "gendep: COND: " ) + (*line) +
                " == " + ((processLine) ? "true" : "false") );
        }
        // if #ifndef
        else if (line->startsWith( IFNDEF_DIRECTIVE ))
        {
          try
          {
            processLine = condState.parseIfndef(
             line->substring( line->firstIndex() + 7 ).trimThis() );
          }
          catch (Exception &e)
          {
            if (Interface::isDebug())
              Interface::printDebug(e.getMessage());
            processLine = cond_truth;
          }
          if (Interface::isDebug())
            Interface::printDebug( String( "gendep: COND: " ) + (*line) +
                " == " + ((processLine) ? "true" : "false") );
        }
        // if #if
        else if (line->startsWith( IF_DIRECTIVE ))
        {
          try
          {
            processLine = condState.parseIf(
             line->substring( line->firstIndex() + 3 ).trimThis(), true );
          }
          catch (Exception &e)
          {
            if (Interface::isDebug())
              Interface::printDebug(e.getMessage());
            processLine = cond_truth;
          }
          if (Interface::isDebug())
            Interface::printDebug( String( "gendep: COND: " ) + (*line) +
                " == " + ((processLine) ? "true" : "false") );
        }
        // if #pragma
        else if (line->startsWith( PRAGMA_DIRECTIVE ))
        {
          if (Interface::isDebug())
            displayWarning( "#pragma directive not processed: "
             + *line, srcfile );
        }
        // if #line
        else if (line->startsWith( LINE_DIRECTIVE ))
        {
          if (Interface::isDebug())
            displayWarning( "#line directive not processed: "
             + *line, srcfile );
        }
        // if #error
        else if (line->startsWith( ERROR_DIRECTIVE ))
        {
          if (Interface::isDebug())
            displayWarning( "#error directive not processed: "
             + *line, srcfile );
        }
        // Else bad directive
        else
        {
          if (Interface::isDebug())
            displayWarning( "Unrecongnized preprocessor directive: "
             + *line, srcfile );
        }
      }
    }
    if (readNextLine)  // get next line from file
    {
      delete line;
      line = 0;
      line = srcfile.getLine( true, false, 0, false );
    }
    else // use portion of line after a begin comment
    {
      *line = afterComment;
      inComment = true;
      readNextLine = true;
    }
  } // while
  } // try
  catch( IOException &e2 )
  {
    // An exception was thrown, and line could not be deleted
    // Delete it here.
    if(line!=0)
    {
      delete line;
      line=0;
    }
  }


  if (line != 0)
    delete line;

  // Check if #if block is not closed
  if (!condState.allBlocksClosed())
    Interface::printError(
     "gendep: Conditional block in file " + srcfilename + " is not closed.");

  if (Interface::isDebug())
    Interface::printDebug(
     "gendep: Done parsing source file " + srcfilename + " ... " );

}


/******************************************************************************
 * Process #include statements
 *
 * @param incline - line from source file containing #include statement
 *
 * @return - true if valid include statement, false if invalid include statement
 */
boolean GenDep::processInclude( String &incline, ConfigFile &srcfile )
{
  String incfile;
  String incfilepath;
  boolean notInTable;

  // get included filename
  incfile = getIncludeFileName( incline );
  if (incfile != StringConstants::EMPTY_STRING)
  {
    // get path to included file
    incfilepath = findIncludeFile( incfile, srcfile );
    if (incfilepath != StringConstants::EMPTY_STRING)
    {
      // Store include file path in hash table in Unixized format
      Path::unixizeThis( incfilepath );

      // Add dependency to hash table
      // NOTE: put() returns false if element is replaced in hash table
      notInTable = depends.put( (SmartCaseString)incfilepath, '\0' );
      if (notInTable)
        hash_misses++;
      else
        hash_hits++;

      // call parseSource for incfilepath recursively
      // if not already in table or -nodup is turned off
      if ((notInTable) || (!no_dup_files))
      {
        nestLevel += 1;
        if (Interface::isDebug())
          Interface::printDebug(
           "gendep: Stepped in: nestLevel = " + (String)nestLevel );
        parseSource( incfilepath );
        nestLevel -= 1;
        if (Interface::isDebug())
          Interface::printDebug(
           "gendep: Stepped out: nestLevel = " + (String)nestLevel );
      }
    }
    else
    {
      // Set condition to quit processing and exit if -q is set
      //  and include file is not found
      if (quit_if_not_found)
      {
        Interface::printError( "gendep: Quit option given ... exiting ..." );
        continueProcessing = false;
      }
    }
  }
  else
  {
    if (Interface::isVerbose())
      displayWarning( "Malformed #include directive: \"" + incline + "\"",
       srcfile );

    return false;
  }

  return true;
}


/******************************************************************************
 * Extracts file name from #include <file.h> or #include "file.h" statements
 *
 * @param incline - source line beginning with #include
 *
 * @return - file name to include or "" if #include directive contains
 * bad syntax
 *
 */
String GenDep::getIncludeFileName( String &incline )
{
  String incfilename;

  // Strip off #include and trim
  incfilename = incline.substring( incline.firstIndex()+8 ).trimThis();

  // Handle double quoted included files
  if (incfilename.startsWith( "\"" ))
  {
    if (incfilename.endsWith( "\"" ))
    {
      incfilename.replaceThis( '\"', ' ' ).trimThis();
      includeFileType = DOUBLE_QUOTE_INCLUDE;
    }
    else
    {
      incfilename = "";
    if (Interface::isDebug())
      Interface::printDebug(
       "Include file beginning with \" must end with \"" );
    }
    return( incfilename );
  }
  // Handle angle bracketed included files
  else if (incfilename.startsWith( "<" ))
  {
    if (incfilename.endsWith( ">" ))
    {
      incfilename.replaceThis( '<', ' ' ).replaceThis( '>', ' ' ).trimThis();
      includeFileType = ANGLE_BRACKET_INCLUDE;
    }
    else
    {
      incfilename = "";
    if (Interface::isDebug())
      Interface::printDebug( "Include file beginning with < must end with >" );
    }
    return( incfilename );
  }
  else
  {
    if (Interface::isDebug())
      Interface::printDebug( "Include file must be delimited by \"\" or <>" );
    return( "" );
  }
}


/******************************************************************************
 * Locates included file by searching current directory and
 * includeDirs directories
 *
 * @param incfile - filename only of file to include
 *
 * @return full path to where include file was found, or "" if file was
 * not found
 *
 */

String GenDep::findIncludeFile( String &incfile, ConfigFile &srcfile )
{
  String incpath;
  int i;
  String tmp;

  if (Path::absolute( incfile ))
  {
    if (Path::exists( incfile ))
    {
      if (Interface::isDebug())
        Interface::printDebug( "gendep: Include file located: " + incfile );
      // If current directory is in exclude directory list, do not use
      if (!isExcludedFile( incfile ))
        return ( incfile );
      // Do not continue searching for file if it in an excluded path
      else
        return (StringConstants::EMPTY_STRING);
    }
  }
  else
  {
    // Check for file in current directory of source file if double quote include
    if (includeFileType == DOUBLE_QUOTE_INCLUDE)
    {
      if (!curSourceDir.equals( "." ))
        incpath = curSourceDir + Path::DIR_SEPARATOR + incfile;
      else
        incpath = incfile;
  
      if (Path::exists( incpath ))
      {
        if (Interface::isDebug())
          Interface::printDebug( "gendep: Include file located: " + incpath );
        // If current directory is in exclude directory list, do not use
        tmp = Path::getcwd() + Path::DIR_SEPARATOR + incpath;
        if (!isExcludedFile( tmp ))
          return ( incpath );
        // Do not continue searching for file if it in an excluded path
        else
          return (StringConstants::EMPTY_STRING);
      }
    }
  
    // Now check in include search path directories
    for (i = includeDirs.firstIndex(); i <= includeDirs.lastIndex(); i++)
    {
      incpath = includeDirs[i] + Path::DIR_SEPARATOR + incfile;
      if (Path::exists( incpath ))
      {
        if (Interface::isDebug())
          Interface::printDebug( "gendep: Include file located: " + incpath );
        // If file is in exclude directory list, do not use
        if (!isExcludedFile( incpath ))
          return( incpath );
        // Do not continue searching for file if it in an excluded path
        else
          return( "" );
      }
    }
  }

  if (includeFileType == DOUBLE_QUOTE_INCLUDE)
    displayWarning( "Include file not located: \"" + incfile + "\"", srcfile );
  else
    displayWarning( "Include file not located: <" + incfile + ">", srcfile );


  return( "" );
}


/******************************************************************************
 * Check if file exists in an excluded path
 *
 * @param incpath - full path to include file
 *
 * @return true if file was found in an excluded path, false if not
 */

boolean GenDep::isExcludedFile( String &incpath )
{
  int i;
  String excDir;
  SmartCaseString smartincpath;

  smartincpath = (SmartCaseString)incpath;
  Path::normalizeThis( smartincpath );
  for (i = excludeDirs.firstIndex(); i <= excludeDirs.lastIndex(); i++)
  {
    excDir = excludeDirs[i];
    Path::normalizeThis( excDir );
    // Add trailing slash if one does not exist
    if (!excDir.endsWith(Path::DIR_SEPARATOR))
      excDir += Path::DIR_SEPARATOR;
    // If relative directory, add current directory
    if (!Path::absolute( excDir ))
      excDir = Path::getcwd() + Path::DIR_SEPARATOR + excDir;
    // Canonicalize paths since we are comparing the
    // strings, not checking file existence
    Path::canonicalizeThis( smartincpath, false );
    Path::canonicalizeThis( excDir, false );
    if (smartincpath.startsWith( excDir ))
    {
      if (Interface::isVerbose())
        Interface::printVerbose( "gendep: File found but excluded: "
         + smartincpath );
      return ( true );
    }
  }

  return ( false );
}


/******************************************************************************
 * Process #define directives
 * This method should handle any type of #define statements legally accepted
 * by the compilerand properly assign the appropriate variable=value combination
 * to the setVars object
 *
 * @param defLineOrig - line of file starting with #define
 *
 * @return - true if valid #define statement, false if not
 *
 *  - limitation: #define VAR1 VAR2+10 will not evaluate
 *  - limitation: will not evaluate function-like macros
 */

boolean GenDep::processDefine( String &defLineOrig, ConfigFile &srcfile )
{
  String varname;
  String varvalue;
  int space_index, paren_index, quote_index;
  String defLine;

  // Trim off #define statement
  defLine = defLineOrig.substring( defLineOrig.firstIndex() + 7 ).trimThis();

  // Variable name cannot start with a double quote
  if (defLine.startsWith( DOUBLE_QUOTE ))
  {
    if (Interface::isDebug())
      displayWarning( "Invalid #define directive: " + defLineOrig, srcfile);
    return false;
  }

  space_index = defLine.indexOf(" ");
  paren_index = defLine.indexOf( LEFT_PAREN );
  quote_index = defLine.indexOf( DOUBLE_QUOTE );

  // Check for function-like macro defintions
  // will ignore function defintion and define variable name with value "1"
  if (paren_index != STRING_NOTFOUND)
  {
    // function-macro, i.e. #define SUM(a,b) (a + b
    if ((paren_index < space_index) || (space_index == STRING_NOTFOUND))
    {
      varname = defLine.substring( defLine.firstIndex(),
       defLine.indexOf( LEFT_PAREN ));
      varvalue = "1";
    }
    // variable value with LEFT_PAREN in it, assign normally
    // i.e. #define LEFTPAREN "("
    else
    {
      varname = defLine.substring( defLine.firstIndex(), space_index );
      varvalue = defLine.substring( defLine.indexOf( " " ) + 1 ).trimThis();
    }
  }

  // var-value pair i.e. #define VAR "value" or #define VAR 0
  else if ((space_index != STRING_NOTFOUND) && ((quote_index > space_index)
     || (quote_index == STRING_NOTFOUND)))
  {
    varname = defLine.substring( defLine.firstIndex(), space_index );
    varvalue = defLine.substring( defLine.indexOf( " " ) + 1 ).trimThis();
  }

  // handle type #define VAR"value", which is legal
  else if (quote_index != STRING_NOTFOUND)
  {
    // separate var and value
    varname = defLine.substring( defLine.firstIndex(), quote_index );
    varvalue = defLine.substring( quote_index+1 );
    // look for end double quote and strip off if found, error if not found
    quote_index = varvalue.indexOf( DOUBLE_QUOTE );
    if (quote_index != STRING_NOTFOUND)
    {
      varvalue = DOUBLE_QUOTE +
       varvalue.substring( varvalue.firstIndex(), quote_index + 1 );
    }
    else
    {
      // No matching end quote - probably caught by comment
      // and quote checking section
      displayWarning( "Invalid #define directive: " + defLine, srcfile);
      return false;
    }
  }
  else  // have only a var, set value = 1, i.e. #define VAR
  {
    varname = defLine;
    varvalue = "1";
  }

  // Define variable in variables hashtable
  variables->put( varname + StringConstants::VAR_SEP_STRING + varvalue );
  return true;

}

/******************************************************************************
 * Process #undef directives
 *
 * @param undefLine - line of file starting with #undef
 *
 * @return - true if valid #define statement, false if not
 *
 */
boolean GenDep::processUndef( String &undefLine, ConfigFile &srcfile )
{
  String varname;

  // Strip of #undef from line
  varname = undefLine.substring( undefLine.firstIndex() + 6 ).trimThis();

  // Do not unset variable with space in it, bad syntax
  if (varname.indexOf( " " ) != STRING_NOTFOUND)
  {
    if (Interface::isDebug())
      displayWarning( "Invalid #undef directive: " + undefLine, srcfile);
    return false;
  }
  // Undefine variable in variables hashtable
  variables->unset( varname );
  return true;

}

/******************************************************************************
 * Create output dependency file and write out dependencies
 *
 * @param srcfilename - full path to source file
 *
 */
void GenDep::writeDepInfo( const String& srcfilename )
{
  String objfile;
  HashKeyEnumeration< SmartCaseString, char > keyenum( &depends );
  const SmartCaseString *depd;
  String depFileName;
  String var;
  String dep;
  ConfigFile* depFile;
  String objSuffix;

  // Get output dependency file name and create output file
  depFileName = cmdline->getQualifiedVariable( "-o" );
  if (depFileName == StringConstants::EMPTY_STRING)
  {
    depFileName = Path::fileRoot( srcfilename, true ) + ".u";
  }

  if (cmdline->isState( "-info" ))
  {
    Interface::printAlways( "gendep: Would have created " + depFileName );
    return;
  }
  depFile = new ConfigFile(depFileName);

  // Get target suffix
  String suff = cmdline->getQualifiedVariable( "-s" );
  if (suff == StringConstants::EMPTY_STRING)
    objSuffix = DEFAULT_TARGET_SUFF;
  else
    objSuffix = suff;

  if ( targetNames.length() > 0)
  {
    // use -targname operand
    objfile = targetNames[targetNames.firstIndex()];
  }
  else if (full_target_path)
  {
    // Use full specified path to targets
    objfile = Path::fileRoot( srcfilename, false ) + objSuffix;
    Path::unixizeThis( objfile );
  }
  else  // File name only
    objfile = Path::fileRoot( Path::fileName( srcfilename ),false ) + objSuffix;

  // Write general info to output file, if fail (read-only, etc.) return
  if (!depFile->putLine( LINE1, false ))
  {
    if (Interface::isDebug())
      Interface::printDebug( "gendep: Error writing to file : " + depFileName );
    return;
  }
  depFile->putLine( LINE2, false );
  depFile->putLine( LINE3 + objfile + ":", false);

  // Output object file depends on source file dependency
#ifdef FILENAME_BLANKS
  objfile.doubleQuoteThis();
  dep = objfile + ": " + Path::unixize( srcfilename ).doubleQuote();
#else
  dep = objfile + ": " + Path::unixize(srcfilename);
#endif
  if (! headersOnly)
  {
    if (Interface::isVerbose())
      Interface::printVerbose( dep );
    depFile->putLine(dep, false);
  }

  // Use enumeration to loop through hash table elements
  while (keyenum.hasMoreElements())
  {
    depd = keyenum.nextElement();
    var = depd->toString();
#ifdef FILENAME_BLANKS
    dep = objfile + ": " + var.doubleQuote();
#else
    dep = objfile + ": " + var;
#endif
    if (Interface::isVerbose())
      Interface::printVerbose( dep );
    depFile->putLine( dep, false );
  }
  depFile->close();
  delete depFile;

  // Print out hash table hit/miss statistice for each source file's hash table
  if (Interface::isDebug())
  {
    Interface::printAlways( "" );  // Blank line
    Interface::printAlways(
     "gendep: Dependency hits and misses for source file : " + srcfilename );
    Interface::printAlways(
     "  Hits (duplicate dependencies) = " + (String)hash_hits );
    Interface::printAlways(
     "  Misses (new dependencies) = " + (String)hash_misses );
    Interface::printAlways("");  // Blank line
  }

}

/******************************************************************************
 *
 */
void GenDep::displayWarning(const String &message, ConfigFile &srcfile)
{
  int lineNumber;
  String pathName;

  // Get file name and line number
  lineNumber = srcfile.getLineNumber();
  pathName = srcfile.getPathname();

  Interface::printWarning(
   "gendep: \"" + pathName + "\", line " + lineNumber + ": " + message);
}


/******************************************************************************
 *
 */
void GenDep::printUsage() const
{
  Interface::printAlways( "Usage: gendep [-Iinclude_directory]... "
      "[-Eexclude_directory]..." );
  Interface::printAlways( "              [-targname target_file] "
      "[-hdrsonly] " );
  Interface::printAlways( "              [-Dvariable]... [-sSuffix] "
      "[-nodup] [-q] " );
  Interface::printAlways( "              [-table] [-abs] [-condfalse]" );
  Interface::printAlways( "              [-respfile response_file]..." );
  Interface::printAlways( "              [-o output_file]" );
  Interface::printAlways( "              [ODE options] source_file..." );
  Interface::printAlways( "" );
  Interface::printAlways( "   ODE options:" );
  Interface::printAlways( "       -quiet -normal -verbose -debug -usage "
      "-version -rev -info -auto" );
}
